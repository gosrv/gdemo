#### 推荐集群结构
引擎没有对集群拓扑结构进行限制，可自行组织，下面的结构可以适用大多数情况，
如无特殊需求可以试用下面的集群拓扑结构，无论是世界服还是单服
```

+------------+  +----------+   +----------+  +-----------+
|  guide     |  |  guide   |   |   match  |  |   team    |
|            |  |          |   |          |  |           |
+-----^------+  +----^-----+   +-----^----+  +-----^-----+
      |              |               |             |
      |              |               |             |
+-----+--------------v---------------+-------------+-----------+
|                                                              |
|                      message queue                           |
|                                                              |
|                                                              |
+------^----------------------^-----------------------^--------+
       |                      |                       |
       |                      |                       |
+------v-------+      +-------v-------+     +---------v--------+
|              |      |               |     |                  |
|   baseapp    |      |    baseapp    |     |      battleapp   |
|              |      |               |     |                  |
+------^-------+      +-------^-------+     +---------^--------+
       |                      |                       |
       |                      |                       |
+------v----------------------v-----------------------v--------+
|                                                              |
|                  gateway (nginx)                             |
|                                                              |
|                                                              |
+--------------------------------------------------------------+

```
要点：
1. 所有服务器可以水平扩展
2. 通过消息队列解耦所有服务器
3. 后端服务器可以进行动态负载均衡（还未实现）
4. 通过滚服实现逻辑热更
5. 前端使用nginx作为网关（如果有必要的话，比如需要https或者wss代理），如果不需要可以直接对外开放
6. baseapp用来处理玩家数据，比如基本数据、背包、宠物、装备等，可以水平扩展
7. battleapp用来处理战斗逻辑，可以水平扩展
8. guide工会服,team服（可以放到一起），可以水平扩展，可以动态负载均衡（还未实现）
9. 每玩家在redis中有一个消息队列，用来传送玩家之间的数据交互
10. 服务节点之间使用nodemq进行通信，目前有两种nodemq，一个使用过tcp连接建立的网络mq，一种是使用redis的list实现的mq

### 集群设施
1. INodeMgr
```go
type INodeMgr interface {
	// 节点是否活跃
	IsNodeActive(nodeUuid string) bool
	// 获取节点信息
	GetNodeInfo(nodeUuid string) *NodeInfo
	// 获取所有节点信息
	GetAllNodesInfo() []*NodeInfo
	// 获取本节点信息
	GetMyNodeInfo() *NodeInfo
}
```
NodeMgr用于查询集群中的节点信息
```go
type NodeInfo struct {
	NodeUuid string
	Meta     map[string]string
	Tick     int64
}
```
节点信息里包含一个uuid，集群内唯一  
Tick是上一次活跃时间  
Meta是节点的元数据，我们可以存储自己的元数据到Meta中，其它节点可以获取到这个元数据  
常用的Meta数据有：节点功能，集群间通信的底层网络接口等  
通过这个元数据我们可以识别出出所有的网关节点、工会节点、中心节点等等  

2. INodeMQ
```go
type INodeMQ interface {
	// uuid是节点的uuid, msg是一个消息
	Push(nodeUuid string, msg interface{}) error
}
```
NodeMQ用于向指定节点发送数据